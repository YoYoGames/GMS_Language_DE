<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>surface_set_target</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Reference for surface_set_target" />
  <meta name="rh-index-keywords" content="surface_set_target" />
  <meta name="search-keywords" content="surface_set_target" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>surface_set_target</h1>
  <p>Mit dieser Funktion setzen Sie alle weiteren Zeichnungen auf die Zielfläche und nicht auf den Bildschirm und können auf diese Weise <span class="notranslate">GameMaker Studio 2</span> anweisen, nur bestimmte Dinge auf die angegebene Fläche zu zeichnen. Bitte beachten Sie, dass, wenn Sie nicht <a href="surface_reset_target.htm"><tt>surface_reset_target()</tt></a>    aufrufen, wird nichts auf den Bildschirm gezeichnet, da alles weitere Zeichnen (auch in anderen Instanzen) auf die Oberfläche erfolgt. Sie sollten sich auch darüber im Klaren sein, dass nichts zu sehen sein wird, wenn die Oberfläche selbst nicht auf dem Bildschirm im draw
    Ereignis einer Instanz auf den Bildschirm gezeichnet wird. Sie können den Rückgabewert dieser Funktion auch als Debug-Werkzeug verwenden, um zu überprüfen, ob das Oberflächenziel gesetzt wurde oder nicht, wobei ein Rückgabewert von 0 ein Fehlschlagen des Setzens des Ziels und jeder andere positive Wert einen Erfolg darstellt.</p>
  <p>Eine Sache, die beachtet werden sollte, ist, dass die Oberflächen <i>gestapelt</i> sind, so dass Sie nicht von Ziel zu Ziel springen können und dann am Ende zum normalen Ziehziel zurückkehren, sondern Sie müssen Rendering-Ziele öffnen und schließen. Dies wird zum Beispiel <b>nicht</b> korrekt funktionieren:</p>
  <p class="code">surface_set_target(surf1);<br> draw_text(32, 32, &quot;surface1&quot;);<br> surface_set_target(surf2);
    <br> draw_text(32, 64, &quot;surface2&quot;);<br> surface_reset_target();
  </p>
  <p>Stattdessen müssen Sie das Ziel für jede der eingestellten Flächen zurücksetzen, ähnlich wie Sie öffnende und schließende Klammern {} für Codeblöcke verwenden müssen. Das obige sollte also entweder als dies geschrieben werden:</p>
  <p class="code">surface_set_target(surf1);<br> draw_text(32, 32, &quot;surface1&quot;);<br> surface_reset_target();
    <br> surface_set_target(surf2);
    <br> draw_text(32, 64, &quot;surface2&quot;);<br> surface_reset_target();
  </p>
  <p>oder als dies:</p>
  <p class="code">surface_set_target(surf1);<br> draw_text(32, 32, &quot;surface1&quot;);<br> surface_set_target(surf2);
    <br> draw_text(32, 64, &quot;surface2&quot;);<br> surface_reset_target();
    <br> surface_reset_target();
  </p>
  <p class="note"><b>HINWEIS</b>: Bei der Arbeit mit Oberflächen besteht die Möglichkeit, dass diese jederzeit aufhören können zu existieren, da sie im Texturspeicher abgelegt sind. Sie sollten <b>IMMER</b> prüfen, ob eine Oberfläche existiert, indem Sie <span style="font-size:1px;"><a href="surface_exists.htm"><tt style="font-size: 14px">surface_exists()</tt></a></span>    überprüfen, bevor Sie sie direkt referenzieren.</p>
  <p> </p>
  <h4>Syntax:</h4>
  <p class="code">surface_set_target(surface_id);</p>
  <table>
    <tbody>
      <tr>
        <th>Argument</th>
        <th>Beschreibung</th>
      </tr>
      <tr>
        <td>oberfläche_id</td>
        <td>Die ID der Oberfläche, die als Zeichenziel festgelegt werden soll.</td>
      </tr>
    </tbody>
  </table>
  <p> </p>
  <h4>Rückgabe:</h4>
  <p class="code">Boolesche</p>
  <p> </p>
  <h4>Beispiel:</h4>
  <p class="code">if view_current = 0<br> {
    <br> surface_set_target(surf);
    <br> mit (obj_Effect)<br> {
    <br> draw_self();
    <br> }
    <br> surface_reset_target();
    <br> }
    <br> sonst
    <br> {
    <br> draw_surface(surf, 0, 0);<br> }
  </p>
  <p>Der obige Code prüft, welche Ansicht gerade gezeichnet wird, und wenn es view[0] ist, setzt er das Zeichenziel auf eine Fläche und zeichnet alle Instanzen des Objekts &quot;obj_Effect&quot;, bevor er das Zeichenziel wieder zurücksetzt. Wenn die Ansicht nicht view[0] ist
    ist, wird die Oberfläche auf den Bildschirm gezeichnet.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Zurück: <a href="Surfaces.htm">Oberflächen</a></div>
        <div style="float:right">Weiter: <a href="surface_set_target_ext.htm">surface_set_target_ext</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Alle Rechte vorbehalten</span></h5>
  </div>
  <!-- KEYWORDS
surface_set_target
-->
  <!-- TAGS
surface_set_target
-->
</body>
</html>